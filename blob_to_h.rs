use std::fs::File;
use std::io::Read;
use std::io::Write;
use std::collections::HashMap;

fn arg_map()-> HashMap<String, String>{
	std::env::args().flat_map(|s| s.find(':').map(|l| (s, l))).map(|sl|{
		let (s, l) = sl;
		unsafe{(
			s.slice_unchecked(0,l).to_string(),
			s.slice_unchecked(l+1,s.len()).to_string()
		)}
	}).collect()
}

fn require<'a>(k:&str, ts:&str, hm:&'a HashMap<String, String>)-> &'a String {
	match hm.get(&k.to_string()) {
		Some(s)=> s,
		None=>{
			println!("missing argument: {}:<{}>", k, ts);
			panic!("invalid args");
		}
	}
}

fn main(){
	let argmap = arg_map();
	if argmap.is_empty() {
		println!("blob_to_h: a utility for converting files into embeddable data for C programs
usage: blob_to_h infile:<file to convert> outfile:<name of header> varname:<name of the constant that will hold the data> [varsizename:<name of the constant that will hold the length of the data, optional, defaults to varname_SIZE>]");
	} else {
		let output_file_name = require("outfile", "output header file name", &argmap);
		let variable_name = require("varname", "name of the variable as it appears in the generated code", &argmap);
		let size_name = match argmap.get(&"varsizename".to_string()) {
			Some(s)=> s.clone(), None=> variable_name.clone() + "_SIZE"
		};
		let input_file_name = require("infile", "name of the file being embedded", &argmap);
		let mut inv = File::open(input_file_name).unwrap();
		let mut out = File::create(output_file_name).unwrap();
		let mut inbuf = Vec::with_capacity(256);
		inv.read_to_end(&mut inbuf).unwrap();
		
		let mut ret:String = format!("//generated by blob_to_h.rs
size_t const {0} = {1};
unsigned char[] const {2} = {{ ", size_name, inbuf.len(), variable_name);
		if inbuf.len() > 0 {
			ret.push_str(&format!("0x{:X}", unsafe{inbuf.get_unchecked(0)}));
			for i in 1 .. inbuf.len() {
				ret.push_str(&format!(",0x{:X}", unsafe{inbuf.get_unchecked(i)})); //Ok maybe the previous ones were silly but at least I get to argue that this is a critical section of code and bounds checking would have a non-negligable impact
			}
		}
		ret.push_str(&" };\n");
		
		out.write_all(ret.as_bytes()).unwrap();
	}
}